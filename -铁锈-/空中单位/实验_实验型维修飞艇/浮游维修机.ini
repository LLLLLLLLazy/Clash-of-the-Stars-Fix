
[core]
name: 浮游维修机
price: 500
maxHp: 1
mass: 100
showInEditor: false

reclaimPrice: 0

techLevel: 1

radius: 10
displayRadius: 10
softCollisionOnAll: 10

isBio: false

energyMax: 20
energyRegen: -${1/60}
dieOnZeroEnergy: true

isBuilder: true
canRepairBuildings: true
canRepairUnits: true

autoRepair: true
nanoRange: 160
nanoBuildSpeed: 2
nanoRepairSpeed: 1

showOnMinimap: false
canNotBeDirectlyAttacked: true
canNotBeGivenOrdersByPlayer: true

numBitsOnDeath: 2

autoTriggerCooldownTime: 0.1s

@memory 维修目标: unit[]

[hiddenAction_$运输]
@copyFrom_skipThisSection:true

[hiddenAction_创建时]
autoTriggerOnEvent: created
addWaypoint_type: move
addWaypoint_maxTime: 0.1s
addWaypoint_position_relativeOffsetFromSelf: 0, 150
alsoTriggerAction: 移动坐标

[hiddenAction_移动坐标]
addWaypoint_type: move
addWaypoint_maxTime: 4.2s
addWaypoint_target_fromReference: customTarget1.readUnitMemory('命令坐标', type='unit')

[hiddenAction_保留能量]
autoTrigger: if not self.hasActiveWaypoint(type='repair')
addResources: energy=0.066


[hiddenAction_开始检索]
autoTrigger: if not self.hasActiveWaypoint and memory.维修目标[0]==null
takeResources_searchOnly: true
takeResources_includeUnitsWithinRange: 500
takeResources_includeUnitsWithinRange_team: own
takeResources_excludeUnitsWithoutTags: units
takeResources_triggerActionForEach: 存入数组
alsoTriggerAction: 距离比对, 距离比对2
alsoTriggerActionRepeat: memory.维修目标.size

[hiddenAction_存入数组]
requireConditional: if thisActionTarget.maxHp-1-thisActionTarget.hp>1 or not thisActionTarget.completed
setUnitMemory: 维修目标[memory.维修目标.size]=thisActionTarget

[hiddenAction_距离比对]
requireConditional:"""
if distanceBetween(self, self.readUnitMemory('维修目标', type='unit', index=memory.维修目标.size-1)) <= distanceBetween(self, self.readUnitMemory('维修目标', type='unit', index=memory.维修目标.size-2))
"""
setUnitMemory: 维修目标[memory.维修目标.size-2]=null
shrinkArrays: 维修目标

[hiddenAction_距离比对2]
requireConditional:"""
if distanceBetween(self, self.readUnitMemory('维修目标', type='unit', index=memory.维修目标.size-1)) > distanceBetween(self, self.readUnitMemory('维修目标', type='unit', index=memory.维修目标.size-2)) and self.readUnitMemory('维修目标', type='unit', index=memory.维修目标.size-2)!=null
"""
setUnitMemory: 维修目标[memory.维修目标.size-1]=null
shrinkArrays: 维修目标


[hiddenAction_锁定维修]
autoTrigger: if memory.维修目标[0]!=null and memory.维修目标[1]==null and not self.hasActiveWaypoint(type='repair')
addWaypoint_type: repair
addWaypoint_prepend: true
addWaypoint_target_fromReference: memory.维修目标[0]

[hiddenAction_锁定取消]
autoTrigger: if memory.维修目标[0].maxHp-1-memory.维修目标[0].hp<1 and memory.维修目标[0].completed and memory.维修目标[1]==null
setUnitMemory: 维修目标[0]=null
shrinkArrays: 维修目标


[decal_光]
onlyWhileActive: true
onlyWhileAlive: true
layer: afterBody
alpha: 0.15
color: #00FF00
image: SHARED:light_50.png
imageScale: 0.6


[graphics]
total_frames: 1
image:        浮游机械.png
image_wreak: NONE
image_turret: NONE
imageScale: 0.8

#AUTO
image_shadow: AUTO
shadowOffsetX:1
shadowOffsetY:1

[attack]
canAttack: false
canAttackFlyingUnits: false
canAttackLandUnits:   false
canAttackUnderwaterUnits: false


turretSize: 0
turretTurnSpeed: 200

maxAttackRange: 200
shootDelay: 5

isFixedFiring: false

[turret_nano]
x: 0
y: 0
invisible: true
warmup: 30
isMainNanoTurret: true

[arm_1]
x:0
y:0
image_end:helicopter_blades.png

drawOverBody: true

spinRate:30

[movement]
movementType: AIR
moveSpeed: 3.0
moveAccelerationSpeed: 0.1
moveDecelerationSpeed: 0.01

targetHeight: 25
targetHeightDrift: 1

reverseSpeedPercentage: 0.1

maxTurnSpeed: 2
turnAcceleration: 0.15

moveSlidingMode :false
moveIgnoringBody:false
moveSlidingDir:  181
